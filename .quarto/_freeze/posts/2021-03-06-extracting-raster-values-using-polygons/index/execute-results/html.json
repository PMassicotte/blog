{
  "hash": "3b033d475a5cc3f89d91f30720d9d3c3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Extracting raster values using the stars R package'\nauthor: 'Philippe Massicotte'\ndate: '2021-03-06'\ncategories: [R, Geospatial]\nimage: 'img/preview.png'\n---\n\n\n\n\n## Introduction\n\nFor a long time, I have been using the `raster` package to manipulate raster data in R. Slowly, I am trying to work my way out with the _new_ `stars` package. In this post, I am exploring different ways to extract values from a raster at different geographic locations. For this exercise, I am using a Landsat 7 image that is provided within the `stars` package. Each pixel has a resolution of 30 meters.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a palette for later\npal <- as.character(paletteer::paletteer_d(\"RColorBrewer::Pastel2\"))\n\n# Open the tif and extract the 1 band\ntif <- system.file(\"tif/L7_ETMs.tif\", package = \"stars\")\nr <- read_stars(tif)[, , , 1]\n\n# What are the dimensions?\nst_dimensions(r)\n#>      from  to  offset delta                     refsys point x/y\n#> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x]\n#> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y]\n#> band    1   1      NA    NA                         NA    NA\n```\n:::\n\n\nThis is what the original image looks like.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(r, key.pos = NULL)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png)\n:::\n:::\n\n\nTo better visualize the process of subsetting raster values, let's crop the image so we can see the pixels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_bbox(r)\n#>      xmin      ymin      xmax      ymax \n#>  288776.3 9110728.8  298722.8 9120760.8\n\nr <- r %>%\n  st_crop(st_bbox(c(\n    xmin = 294000,\n    xmax = 294500,\n    ymin = 9110800,\n    ymax = 9111200\n  ), crs = st_crs(r)))\n\nplot(r, reset = FALSE, key.pos = NULL)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png)\n:::\n:::\n\n\nWe can also display the value of each pixel by using `text_values = TRUE`. This is also where I am using the `pal` colour vector I created earlier.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(r, text_values = TRUE, col = pal, key.pos = NULL)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png)\n:::\n:::\n\n\n## Sampling random locations\n\nUsing this new raster, let's randomly sample four points.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123456)\n\n# Random sampling of 4 points\npts <- st_sample(st_as_sfc(st_bbox(r)), 4)\n\n# Visualize them\nplot(r, text_values = TRUE, col = pal, key.pos = NULL, reset = FALSE)\nplot(\n  pts,\n  add = TRUE,\n  pch = 21,\n  cex = 2,\n  bg = alpha(\"red\", 0.5),\n  col = alpha(\"red\", 0.5)\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png)\n:::\n:::\n\n\n## Extracting raster values using the sampled points\n\nExtracting raster values at point locations can be done using the `st_extract()` function. As expected, four values have been extracted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npts_values <- st_extract(r, pts)\npts_values\n#> Simple feature collection with 4 features and 1 field\n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 294167 ymin: 9110827 xmax: 294401 ymax: 9111014\n#> Projected CRS: SIRGAS 2000 / UTM zone 25S\n#>   L7_ETMs.tif                 geometry\n#> 1          71   POINT (294401 9110940)\n#> 2          70 POINT (294378.3 9110871)\n#> 3          72 POINT (294192.5 9111014)\n#> 4          68   POINT (294167 9110827)\n```\n:::\n\n\n## Extracting raster values using buffers around the sampled points\n\nI found that extracting raster values using polygons was a bit more tedious (at least at this stage of my understanding of the `stars` package).\n\n### Generate buffers\n\nLet's generate buffers of 30 meters around each of the four sampled pixels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoly <- st_buffer(pts, dist = 30)\n\nclass(poly)\n#> [1] \"sfc_POLYGON\" \"sfc\"\n\nplot(r, text_values = TRUE, col = pal, key.pos = NULL, reset = FALSE)\nplot(st_sfc(poly), add = TRUE, border = \"red\", lwd = 2, col = NA)\nplot(\n  pts,\n  add = TRUE,\n  pch = 21,\n  cex = 2,\n  bg = alpha(\"red\", 0.5),\n  col = alpha(\"red\", 0.5)\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png)\n:::\n:::\n\n\nWe can visualize which pixels fall within each buffer. Looking at the next figure, one can ask why there are not always the same number of pixels in each buffer. The reason is that the arc of the circle must pass through the center of each pixel to be included in the buffer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr[poly] %>%\n  st_as_sf() %>%\n  ggplot() +\n  geom_sf(aes(fill = factor(V1)), color = \"#3c3c3c\") +\n  geom_sf(data = st_sfc(poly), fill = NA, color = \"blue\") +\n  geom_sf(data = pts, color = \"red\", size = 2) +\n  geom_sf_text(aes(label = V1)) +\n  paletteer::scale_fill_paletteer_d(\"RColorBrewer::Pastel2\") +\n  theme(\n    legend.position = \"none\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png)\n:::\n:::\n\n\n### Extracting pixel values covered by the polygons\n\nNow that we have defined four buffers with a 30 meters radius, we could be tempted to re-use `st_extract()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_extract(r, poly)\n#> stars object with 2 dimensions and 1 attribute\n#> attribute(s):\n#>                  Min.  1st Qu. Median     Mean 3rd Qu. Max.\n#> L7_ETMs.tif  68.33333 69.83333     71 70.95833  72.125 73.5\n#> dimension(s):\n#>          from to                     refsys point\n#> geometry    1  4 SIRGAS 2000 / UTM zone 25S FALSE\n#> band        1  1                         NA    NA\n#>                                                                 values\n#> geometry POLYGON ((294431 9110940,...,...,POLYGON ((294197 9110827,...\n#> band                                                              NULL\n```\n:::\n\n\nSurprisingly, we can not use `st_extract()` with polygons. One option is to use `aggregate()`. In our example, between three and four pixels are falling under each buffer. This is why we have to tell the `aggregate()` function how to summarize the values within each buffer with the `FUN` parameter.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract the average value per polygon\nx <- aggregate(r, poly, FUN = mean)\nst_as_sf(x)\n#> Simple feature collection with 4 features and 1 field\n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 294137 ymin: 9110797 xmax: 294431 ymax: 9111044\n#> Projected CRS: SIRGAS 2000 / UTM zone 25S\n#>         V1                       geometry\n#> 1 68.33333 POLYGON ((294431 9110940, 2...\n#> 2 70.33333 POLYGON ((294408.3 9110871,...\n#> 3 73.50000 POLYGON ((294222.5 9111014,...\n#> 4 71.66667 POLYGON ((294197 9110827, 2...\n\n# Extract the minimum value per polygon\nx <- aggregate(r, poly, FUN = min)\nst_as_sf(x)\n#> Simple feature collection with 4 features and 1 field\n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 294137 ymin: 9110797 xmax: 294431 ymax: 9111044\n#> Projected CRS: SIRGAS 2000 / UTM zone 25S\n#>   V1                       geometry\n#> 1 67 POLYGON ((294431 9110940, 2...\n#> 2 67 POLYGON ((294408.3 9110871,...\n#> 3 72 POLYGON ((294222.5 9111014,...\n#> 4 68 POLYGON ((294197 9110827, 2...\n\n# Extract the maximum value per polygon\nx <- aggregate(r, poly, FUN = max)\nst_as_sf(x)\n#> Simple feature collection with 4 features and 1 field\n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 294137 ymin: 9110797 xmax: 294431 ymax: 9111044\n#> Projected CRS: SIRGAS 2000 / UTM zone 25S\n#>   V1                       geometry\n#> 1 71 POLYGON ((294431 9110940, 2...\n#> 2 74 POLYGON ((294408.3 9110871,...\n#> 3 76 POLYGON ((294222.5 9111014,...\n#> 4 75 POLYGON ((294197 9110827, 2...\n```\n:::\n\n\n### Overlapping polygons\n\nThe method using the `aggregate()` function is largely based on [an answer I received on stackoverflow](https://stackoverflow.com/questions/66283846/how-to-extract-values-from-a-raster-using-polygons-with-the-r-stars-package). As specified by the user who answered my question, there is one catch.\n\n> Keep in mind that if there is overlap between polygons (unlike in this example) then each raster value is only \"counted\" once, in the first polygon it falls in (to comply with the ordinary behaviour of aggregate).\n\nTo demonstrate it, we will increase the buffer radius to 90 meters. As seen in the next figure, two buffers are overlapping.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create 90 meters radius buffers\npoly <- st_buffer(pts, dist = 90)\n\nplot(r, text_values = TRUE, col = pal, key.pos = NULL, reset = FALSE)\nplot(st_sfc(poly), add = TRUE, border = \"red\", lwd = 2, col = NA)\nplot(\n  pts_values,\n  add = TRUE,\n  pch = 21,\n  cex = 2,\n  bg = alpha(\"red\", 0.5),\n  col = alpha(\"red\", 0.5)\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png)\n:::\n:::\n\n\nNow let's calculate the average pixel value in each polygon.\n\n#### Using the `aggregate()` function\n\nAs previously done with the smaller polygons, we can also use the `aggregate()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naveraged_using_aggregate <- aggregate(r, poly, FUN = mean) %>%\n  st_as_sf()\n\naveraged_using_aggregate\n#> Simple feature collection with 4 features and 1 field\n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 294077 ymin: 9110737 xmax: 294491 ymax: 9111104\n#> Projected CRS: SIRGAS 2000 / UTM zone 25S\n#>         V1                       geometry\n#> 1 71.48485 POLYGON ((294491 9110940, 2...\n#> 2 71.40000 POLYGON ((294468.3 9110871,...\n#> 3 71.90625 POLYGON ((294282.5 9111014,...\n#> 4 70.92000 POLYGON ((294257 9110827, 2...\n```\n:::\n\n\n#### Using the `st_join()` function (manually)\n\nFirst, convert the polygons into a `sf` object and assign a unique id to each polygon.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoly_sf <- poly %>%\n  st_as_sf() %>%\n  rowid_to_column(var = \"poly_id\")\n\npoly_sf\n#> Simple feature collection with 4 features and 1 field\n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 294077 ymin: 9110737 xmax: 294491 ymax: 9111104\n#> Projected CRS: SIRGAS 2000 / UTM zone 25S\n#>   poly_id                              x\n#> 1       1 POLYGON ((294491 9110940, 2...\n#> 2       2 POLYGON ((294468.3 9110871,...\n#> 3       3 POLYGON ((294282.5 9111014,...\n#> 4       4 POLYGON ((294257 9110827, 2...\n```\n:::\n\n\nConvert the raster into a `sf` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_sf <- st_as_sf(r)\n\nr_sf\n#> Simple feature collection with 270 features and 1 field\n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 293991.8 ymin: 9110786 xmax: 294504.8 ymax: 9111213\n#> Projected CRS: SIRGAS 2000 / UTM zone 25S\n#> First 10 features:\n#>    V1                       geometry\n#> 1  87 POLYGON ((293991.8 9111213,...\n#> 2  83 POLYGON ((294020.3 9111213,...\n#> 3  82 POLYGON ((294048.8 9111213,...\n#> 4  76 POLYGON ((294077.3 9111213,...\n#> 5  80 POLYGON ((294105.8 9111213,...\n#> 6  85 POLYGON ((294134.3 9111213,...\n#> 7  83 POLYGON ((294162.8 9111213,...\n#> 8  87 POLYGON ((294191.3 9111213,...\n#> 9  85 POLYGON ((294219.8 9111213,...\n#> 10 79 POLYGON ((294248.3 9111213,...\n```\n:::\n\n\nJoin the raster and the polygons together and drop the pixels that were not matched to any buffer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_sf <- st_join(r_sf, poly_sf) %>%\n  drop_na(poly_id)\n```\n:::\n\n\nWe can now visualize the pixels in each buffer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_sf %>%\n  ggplot(aes(color = factor(poly_id))) +\n  geom_sf(fill = NA, color = \"black\", size = 0.25) +\n  geom_sf(data = poly_sf, fill = NA) +\n  geom_sf_text(aes(label = V1), color = \"#3c3c3c\") +\n  scale_color_manual(\n    breaks = c(1, 2, 3, 4),\n    values = c(\"red\", \"blue\", \"yellow\", \"green\")\n  ) +\n  facet_wrap(~poly_id)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png)\n:::\n:::\n\n\nFinally, we can calculate the average pixel values in each polygon.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naveraged_using_st_join <- df_sf %>%\n  group_by(poly_id) %>%\n  summarise(V1 = mean(V1), n = n())\n\naveraged_using_st_join\n#> Simple feature collection with 4 features and 3 fields\n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 294048.8 ymin: 9110786 xmax: 294504.8 ymax: 9111128\n#> Projected CRS: SIRGAS 2000 / UTM zone 25S\n#> # A tibble: 4 × 4\n#>   poly_id    V1     n                                                   geometry\n#>     <int> <dbl> <int>                                              <POLYGON [m]>\n#> 1       1  72.8    45 ((294305.3 9110871, 294305.3 9110900, 294305.3 9110928, 2…\n#> 2       2  71.0    42 ((294276.8 9110814, 294276.8 9110843, 294276.8 9110871, 2…\n#> 3       3  71.2    48 ((294077.3 9111014, 294077.3 9111042, 294105.8 9111042, 2…\n#> 4       4  70.7    33 ((294048.8 9110843, 294077.3 9110843, 294077.3 9110871, 2…\n```\n:::\n\n\nIf we compare both the `aggregate()` and `st_join()` methods, we can see that there are differences.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naveraged_using_aggregate$V1\n#> [1] 71.48485 71.40000 71.90625 70.92000\naveraged_using_st_join$V1\n#> [1] 72.80000 71.02381 71.22917 70.72727\n```\n:::\n\n\nAt this time of writing this, I can not find why I am getting different values. Please leave out a comment if you have an idea!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}