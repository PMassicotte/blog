{"title":"Extracting raster values using the stars R package","markdown":{"yaml":{"title":"Extracting raster values using the stars R package","author":"Philippe Massicotte","date":"2021-03-06","categories":["R","Geospatial"],"image":"img/preview.png"},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n\nFor a long time, I have been using the `raster` package to manipulate raster data in R. Slowly, I am trying to work my way out with the *new* `stars` package. In this post, I am exploring different ways to extract values from a raster at different geographic locations. For this exercise, I am using a Landsat 7 image that is provided within the `stars` package. Each pixel has a resolution of 30 meters.\n\n```{r setup, include=FALSE}\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(stars)\nlibrary(ggpmthemes)\n\ntheme_set(theme_maven())\n```\n\n```{r message=FALSE}\n# Create a palette for later\npal <- as.character(paletteer::paletteer_d(\"RColorBrewer::Pastel2\"))\n\n# Open the tif and extract the 1 band\ntif <- system.file(\"tif/L7_ETMs.tif\", package = \"stars\")\nr <- read_stars(tif)[, , , 1]\n\n# What are the dimensions?\nst_dimensions(r)\n```\n\nThis is what the original image looks like.\n\n```{r}\nplot(r, key.pos = NULL)\n```\n\nTo better visualize the process of subsetting raster values, let's crop the image so we can see the pixels.\n\n```{r}\nst_bbox(r)\n\nr <- r %>%\n  st_crop(st_bbox(c(\n    xmin = 294000,\n    xmax = 294500,\n    ymin = 9110800,\n    ymax = 9111200\n  ), crs = st_crs(r)))\n\nplot(r, reset = FALSE, key.pos = NULL)\n```\n\nWe can also display the value of each pixel by using `text_values = TRUE`. This is also where I am using the `pal` colour vector I created earlier.\n\n```{r}\nplot(r, text_values = TRUE, col = pal, key.pos = NULL)\n```\n\n## Sampling random locations\n\nUsing this new raster, let's randomly sample four points.\n\n```{r}\nset.seed(123456)\n\n# Random sampling of 4 points\npts <- st_sample(st_as_sfc(st_bbox(r)), 4)\n\n# Visualize them\nplot(r, text_values = TRUE, col = pal, key.pos = NULL, reset = FALSE)\nplot(\n  pts,\n  add = TRUE,\n  pch = 21,\n  cex = 2,\n  bg = alpha(\"red\", 0.5),\n  col = alpha(\"red\", 0.5)\n)\n```\n\n## Extracting raster values using the sampled points\n\nExtracting raster values at point locations can be done using the `st_extract()` function. As expected, four values have been extracted.\n\n```{r}\npts_values <- st_extract(r, pts)\npts_values\n```\n\n## Extracting raster values using buffers around the sampled points\n\nI found that extracting raster values using polygons was a bit more tedious (at least at this stage of my understanding of the `stars` package).\n\n### Generate buffers\n\nLet's generate buffers of 30 meters around each of the four sampled pixels.\n\n```{r}\npoly <- st_buffer(pts, dist = 30)\n\nclass(poly)\n\nplot(r, text_values = TRUE, col = pal, key.pos = NULL, reset = FALSE)\nplot(st_sfc(poly), add = TRUE, border = \"red\", lwd = 2, col = NA)\nplot(\n  pts,\n  add = TRUE,\n  pch = 21,\n  cex = 2,\n  bg = alpha(\"red\", 0.5),\n  col = alpha(\"red\", 0.5)\n)\n```\n\nWe can visualize which pixels fall within each buffer. Looking at the next figure, one can ask why there are not always the same number of pixels in each buffer. The reason is that the arc of the circle must pass through the center of each pixel to be included in the buffer.\n\n```{r}\nr[poly] %>% \n  st_as_sf() %>% \n  ggplot() +\n  geom_sf(aes(fill = factor(V1)), color = \"#3c3c3c\") +\n  geom_sf(data = st_sfc(poly), fill = NA, color = \"blue\") +\n  geom_sf(data = pts, color = \"red\", size = 2) +\n  geom_sf_text(aes(label = V1)) +\n  paletteer::scale_fill_paletteer_d(\"RColorBrewer::Pastel2\") +\n  theme(\n    legend.position = \"none\"\n  )\n```\n\n### Extracting pixel values covered by the polygons\n\nNow that we have defined four buffers with a 30 meters radius, we could be tempted to re-use `st_extract()`.\n\n```{r, error=TRUE}\nst_extract(r, poly)\n```\n\nSurprisingly, we can not use `st_extract()` with polygons. One option is to use `aggregate()`. In our example, between three and four pixels are falling under each buffer. This is why we have to tell the `aggregate()` function how to summarize the values within each buffer with the `FUN` parameter.\n\n```{r}\n# Extract the average value per polygon\nx <- aggregate(r, poly, FUN = mean)\nst_as_sf(x)\n\n# Extract the minimum value per polygon\nx <- aggregate(r, poly, FUN = min)\nst_as_sf(x)\n\n# Extract the maximum value per polygon\nx <- aggregate(r, poly, FUN = max)\nst_as_sf(x)\n```\n\n### Overlapping polygons\n\nThe method using the `aggregate()` function is largely based on [an answer I received on stackoverflow](https://stackoverflow.com/questions/66283846/how-to-extract-values-from-a-raster-using-polygons-with-the-r-stars-package). As specified by the user who answered my question, there is one catch.\n\n> Keep in mind that if there is overlap between polygons (unlike in this example) then each raster value is only \"counted\" once, in the first polygon it falls in (to comply with the ordinary behaviour of aggregate).\n\nTo demonstrate it, we will increase the buffer radius to 90 meters. As seen in the next figure, two buffers are overlapping.\n\n```{r}\n# Create 90 meters radius buffers\npoly <- st_buffer(pts, dist = 90)\n\nplot(r, text_values = TRUE, col = pal, key.pos = NULL, reset = FALSE)\nplot(st_sfc(poly), add = TRUE, border = \"red\", lwd = 2, col = NA)\nplot(\n  pts_values,\n  add = TRUE,\n  pch = 21,\n  cex = 2,\n  bg = alpha(\"red\", 0.5),\n  col = alpha(\"red\", 0.5)\n)\n```\n\nNow let's calculate the average pixel value in each polygon.\n\n#### Using the `aggregate()` function\n\nAs previously done with the smaller polygons, we can also use the `aggregate()` function.\n\n```{r}\naveraged_using_aggregate <- aggregate(r, poly, FUN = mean) %>% \n  st_as_sf()\n\naveraged_using_aggregate\n```\n\n#### Using the `st_join()` function (manually)\n\nFirst, convert the polygons into a `sf` object and assign a unique id to each polygon.\n\n```{r}\npoly_sf <- poly %>% \n  st_as_sf() %>% \n  rowid_to_column(var = \"poly_id\")\n\npoly_sf\n```\n\nConvert the raster into a `sf` object.\n\n```{r}\nr_sf <- st_as_sf(r)\n\nr_sf\n```\n\nJoin the raster and the polygons together and drop the pixels that were not matched to any buffer.\n\n```{r}\ndf_sf <- st_join(r_sf, poly_sf) %>% \n  drop_na(poly_id)\n```\n\nWe can now visualize the pixels in each buffer.\n\n```{r, fig.height=10, fig.width=10}\ndf_sf %>% \n  ggplot(aes(color = factor(poly_id))) +\n  geom_sf(fill = NA, color = \"black\", size = 0.25) +\n  geom_sf(data = poly_sf, fill = NA) +\n  geom_sf_text(aes(label = V1), color = \"#3c3c3c\") +\n  scale_color_manual(\n    breaks = c(1, 2, 3, 4),\n    values = c(\"red\", \"blue\", \"yellow\", \"green\")\n  ) +\n  facet_wrap(~poly_id)\n```\n\nFinally, we can calculate the average pixel values in each polygon.\n\n```{r}\naveraged_using_st_join <- df_sf %>% \n  group_by(poly_id) %>% \n  summarise(V1 = mean(V1), n = n()) \n\naveraged_using_st_join\n```\n\nIf we compare both the `aggregate()` and `st_join()` methods, we can see that there are differences.\n\n```{r}\naveraged_using_aggregate$V1\naveraged_using_st_join$V1\n```\n\nAt this time of writing this, I can not find why I am getting different values. Please leave out a comment if you have an idea!\n","srcMarkdownNoYaml":"\n\n## Introduction\n\nFor a long time, I have been using the `raster` package to manipulate raster data in R. Slowly, I am trying to work my way out with the *new* `stars` package. In this post, I am exploring different ways to extract values from a raster at different geographic locations. For this exercise, I am using a Landsat 7 image that is provided within the `stars` package. Each pixel has a resolution of 30 meters.\n\n```{r setup, include=FALSE}\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(stars)\nlibrary(ggpmthemes)\n\ntheme_set(theme_maven())\n```\n\n```{r message=FALSE}\n# Create a palette for later\npal <- as.character(paletteer::paletteer_d(\"RColorBrewer::Pastel2\"))\n\n# Open the tif and extract the 1 band\ntif <- system.file(\"tif/L7_ETMs.tif\", package = \"stars\")\nr <- read_stars(tif)[, , , 1]\n\n# What are the dimensions?\nst_dimensions(r)\n```\n\nThis is what the original image looks like.\n\n```{r}\nplot(r, key.pos = NULL)\n```\n\nTo better visualize the process of subsetting raster values, let's crop the image so we can see the pixels.\n\n```{r}\nst_bbox(r)\n\nr <- r %>%\n  st_crop(st_bbox(c(\n    xmin = 294000,\n    xmax = 294500,\n    ymin = 9110800,\n    ymax = 9111200\n  ), crs = st_crs(r)))\n\nplot(r, reset = FALSE, key.pos = NULL)\n```\n\nWe can also display the value of each pixel by using `text_values = TRUE`. This is also where I am using the `pal` colour vector I created earlier.\n\n```{r}\nplot(r, text_values = TRUE, col = pal, key.pos = NULL)\n```\n\n## Sampling random locations\n\nUsing this new raster, let's randomly sample four points.\n\n```{r}\nset.seed(123456)\n\n# Random sampling of 4 points\npts <- st_sample(st_as_sfc(st_bbox(r)), 4)\n\n# Visualize them\nplot(r, text_values = TRUE, col = pal, key.pos = NULL, reset = FALSE)\nplot(\n  pts,\n  add = TRUE,\n  pch = 21,\n  cex = 2,\n  bg = alpha(\"red\", 0.5),\n  col = alpha(\"red\", 0.5)\n)\n```\n\n## Extracting raster values using the sampled points\n\nExtracting raster values at point locations can be done using the `st_extract()` function. As expected, four values have been extracted.\n\n```{r}\npts_values <- st_extract(r, pts)\npts_values\n```\n\n## Extracting raster values using buffers around the sampled points\n\nI found that extracting raster values using polygons was a bit more tedious (at least at this stage of my understanding of the `stars` package).\n\n### Generate buffers\n\nLet's generate buffers of 30 meters around each of the four sampled pixels.\n\n```{r}\npoly <- st_buffer(pts, dist = 30)\n\nclass(poly)\n\nplot(r, text_values = TRUE, col = pal, key.pos = NULL, reset = FALSE)\nplot(st_sfc(poly), add = TRUE, border = \"red\", lwd = 2, col = NA)\nplot(\n  pts,\n  add = TRUE,\n  pch = 21,\n  cex = 2,\n  bg = alpha(\"red\", 0.5),\n  col = alpha(\"red\", 0.5)\n)\n```\n\nWe can visualize which pixels fall within each buffer. Looking at the next figure, one can ask why there are not always the same number of pixels in each buffer. The reason is that the arc of the circle must pass through the center of each pixel to be included in the buffer.\n\n```{r}\nr[poly] %>% \n  st_as_sf() %>% \n  ggplot() +\n  geom_sf(aes(fill = factor(V1)), color = \"#3c3c3c\") +\n  geom_sf(data = st_sfc(poly), fill = NA, color = \"blue\") +\n  geom_sf(data = pts, color = \"red\", size = 2) +\n  geom_sf_text(aes(label = V1)) +\n  paletteer::scale_fill_paletteer_d(\"RColorBrewer::Pastel2\") +\n  theme(\n    legend.position = \"none\"\n  )\n```\n\n### Extracting pixel values covered by the polygons\n\nNow that we have defined four buffers with a 30 meters radius, we could be tempted to re-use `st_extract()`.\n\n```{r, error=TRUE}\nst_extract(r, poly)\n```\n\nSurprisingly, we can not use `st_extract()` with polygons. One option is to use `aggregate()`. In our example, between three and four pixels are falling under each buffer. This is why we have to tell the `aggregate()` function how to summarize the values within each buffer with the `FUN` parameter.\n\n```{r}\n# Extract the average value per polygon\nx <- aggregate(r, poly, FUN = mean)\nst_as_sf(x)\n\n# Extract the minimum value per polygon\nx <- aggregate(r, poly, FUN = min)\nst_as_sf(x)\n\n# Extract the maximum value per polygon\nx <- aggregate(r, poly, FUN = max)\nst_as_sf(x)\n```\n\n### Overlapping polygons\n\nThe method using the `aggregate()` function is largely based on [an answer I received on stackoverflow](https://stackoverflow.com/questions/66283846/how-to-extract-values-from-a-raster-using-polygons-with-the-r-stars-package). As specified by the user who answered my question, there is one catch.\n\n> Keep in mind that if there is overlap between polygons (unlike in this example) then each raster value is only \"counted\" once, in the first polygon it falls in (to comply with the ordinary behaviour of aggregate).\n\nTo demonstrate it, we will increase the buffer radius to 90 meters. As seen in the next figure, two buffers are overlapping.\n\n```{r}\n# Create 90 meters radius buffers\npoly <- st_buffer(pts, dist = 90)\n\nplot(r, text_values = TRUE, col = pal, key.pos = NULL, reset = FALSE)\nplot(st_sfc(poly), add = TRUE, border = \"red\", lwd = 2, col = NA)\nplot(\n  pts_values,\n  add = TRUE,\n  pch = 21,\n  cex = 2,\n  bg = alpha(\"red\", 0.5),\n  col = alpha(\"red\", 0.5)\n)\n```\n\nNow let's calculate the average pixel value in each polygon.\n\n#### Using the `aggregate()` function\n\nAs previously done with the smaller polygons, we can also use the `aggregate()` function.\n\n```{r}\naveraged_using_aggregate <- aggregate(r, poly, FUN = mean) %>% \n  st_as_sf()\n\naveraged_using_aggregate\n```\n\n#### Using the `st_join()` function (manually)\n\nFirst, convert the polygons into a `sf` object and assign a unique id to each polygon.\n\n```{r}\npoly_sf <- poly %>% \n  st_as_sf() %>% \n  rowid_to_column(var = \"poly_id\")\n\npoly_sf\n```\n\nConvert the raster into a `sf` object.\n\n```{r}\nr_sf <- st_as_sf(r)\n\nr_sf\n```\n\nJoin the raster and the polygons together and drop the pixels that were not matched to any buffer.\n\n```{r}\ndf_sf <- st_join(r_sf, poly_sf) %>% \n  drop_na(poly_id)\n```\n\nWe can now visualize the pixels in each buffer.\n\n```{r, fig.height=10, fig.width=10}\ndf_sf %>% \n  ggplot(aes(color = factor(poly_id))) +\n  geom_sf(fill = NA, color = \"black\", size = 0.25) +\n  geom_sf(data = poly_sf, fill = NA) +\n  geom_sf_text(aes(label = V1), color = \"#3c3c3c\") +\n  scale_color_manual(\n    breaks = c(1, 2, 3, 4),\n    values = c(\"red\", \"blue\", \"yellow\", \"green\")\n  ) +\n  facet_wrap(~poly_id)\n```\n\nFinally, we can calculate the average pixel values in each polygon.\n\n```{r}\naveraged_using_st_join <- df_sf %>% \n  group_by(poly_id) %>% \n  summarise(V1 = mean(V1), n = n()) \n\naveraged_using_st_join\n```\n\nIf we compare both the `aggregate()` and `st_join()` methods, we can see that there are differences.\n\n```{r}\naveraged_using_aggregate$V1\naveraged_using_st_join$V1\n```\n\nAt this time of writing this, I can not find why I am getting different values. Please leave out a comment if you have an idea!\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":8,"fig-height":5,"fig-format":"png","fig-dpi":600,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"center","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"highlight-style":"arrow","output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.340","knitr":{"opts_chunk":{"collapse":true,"comment":"#>"}},"comments":{"utterances":{"repo":"pmassicotte/PMassicotte.github.io"}},"theme":{"light":"flatly","dark":"darkly"},"mainfont":"Montserrat","fig-asp":0.618,"title-block-banner":true,"title":"Extracting raster values using the stars R package","author":"Philippe Massicotte","date":"2021-03-06","categories":["R","Geospatial"],"image":"img/preview.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}